# イミュータブルデータモデルについて

このドキュメントでは、イミュータブル（不変）データモデルの基本的な概念について、図を用いて分かりやすく解説します。

## 1. イミュータブルデータモデルとは？

イミュータブルデータモデルとは、一度作成されたデータを**変更しない**という原則に基づいたデータ管理の手法です。

データに変更が必要な場合、既存のデータを直接書き換える（上書きする）のではなく、変更内容を反映した**新しいデータを作成**します。これにより、データの変更履歴がすべて保存され、各時点でのデータの状態を正確に追跡することができます。

## 2. 可変（ミュータブル）モデルとの比較

伝統的なデータベースの多くは、可変（ミュータブル）モデルを採用しています。ここでは、ユーザーのメールアドレスを変更するシナリオを例に、両者の違いを見てみましょう。

### 可変（ミュータブル）モデル

既存のレコードの値を直接更新します。

- **シナリオ**: `user_id: 1` のユーザーがメールアドレスを `A@example.com` から `B@example.com` に変更。
- **動作**: `Users` テーブル内の該当レコードの `email` カラムを直接上書きします。
- **結果**: 変更前のメールアドレス `A@example.com` の情報は失われます。

```mermaid
graph TD
    subgraph Users Table (変更前)
        U1["user_id: 1<br>name: 'Taro'<br>email: 'A@example.com'"]
    end

    U1 -- UPDATE --> U1_after;

    subgraph Users Table (変更後)
        U1_after["user_id: 1<br>name: 'Taro'<br>email: 'B@example.com'"]
    end
```

### 不変（イミュータブル）モデル

新しいバージョンのデータを作成し、それを最新の状態とします。

- **シナリオ**: `user_id: 1` のユーザーがメールアドレスを `A@example.com` から `B@example.com` に変更。
- **動作**:
    1. `email` が `B@example.com` となった新しいレコードを作成します。バージョン番号をインクリメント（`v2`）します。
    2. 古いレコード（`v1`）は変更せずにそのまま残します。
- **結果**: `v1` と `v2` の両方のデータが保持され、いつでも過去の状態を参照できます。

```mermaid
graph TD
    subgraph User States (user_id: 1)
        direction LR
        U1_v1["version: 1<br>name: 'Taro'<br>email: 'A@example.com'<br>updated_at: '2023-10-01'"]
        U1_v2["version: 2<br>name: 'Taro'<br>email: 'B@example.com'<br>updated_at: '2023-10-26'"]
        
        U1_v1 -- 変更 --> U1_v2
    end

    subgraph Current User View
        direction TB
        style Latest fill:#d4fcd7
        Latest("最新のユーザー情報<br>(クエリ: user_id=1, version=latest)") --> U1_v2
    end
```

## 3. イミュータブルデータモデルの利点

- **完全な変更履歴（監査ログ）**:
  - データのすべての変更が記録として残るため、「いつ」「誰が」「何を」変更したかの追跡が容易です。これは監査やコンプライアンスの要件を満たすのに役立ちます。

- **デバッグとトラブルシューティングの簡素化**:
  - 問題が発生した際に、データの変更履歴を遡って原因を特定しやすくなります。

- **並行処理の安全性**:
  - データは変更されないため、読み取り処理はロックを考慮する必要がなく、競合が発生しません。これにより、システムのパフォーマンスと安定性が向上します。

- **状態の再現性**:
  - 特定の時点のデータ状態を簡単に復元・再現できます。
